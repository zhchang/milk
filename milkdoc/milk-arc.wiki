======Milk 技术架构======

Milk技术是为了解决以下几个问题而设计出来的：
  * 在小团队内，使用一种通用的方式开发适配多种硬件的游戏和应用。
  * 当游戏或应用发布给用户之后，可以通过网络更新游戏和应用的逻辑。
  * 提高团队开发效率，提供完整的工具链。

milk的技术架构有以下4个组成部分：

  * Milk 语言
  * Milk 编译器
  * Milk 部署器
  * Milk 部署环境 (MgServer)
  * Milk runtime (客户端)

=====Milk 语言=====

Milk语言是面向游戏开发使用的编译语言。编程人员的输入是按照milk语法组织好的文本文件，经过编译器编译输出的是二进制的字节码，供milk-runtime解析执行。

Milk语言有两大组成部分:
  * Milk 游戏逻辑
  * Milk 图形界面

其中，游戏逻辑对游戏中常用的对象做了抽象，封装。有了这些抽象，milk程序具备向硬件上面输出图形，文字，声音的能力。有了上述能力，milk程序可以执行动画特效，文字特效，游戏中需要向玩家显示以及与玩家交互的大多数任务都可以完成。图形界面则对网页元素进行了封装，主要用来向玩家展示信息，以及获取输入，进行提示（对话框）等等。

====milk游戏逻辑====
milk用屏幕来管理游戏元素。屏幕可以包含任意多的子元素，子元素如果是容器，则可以进一步包含子元素。这些元素可以是图形，文字。每个元素必须通过直属或者远亲关系联系到屏幕，才可以在屏幕上面出现。元素出现在屏幕上的先后顺序，取决于元素的父元素以及元素本身的景深属性。更改元素的位置，景深，父元素，以及元素自身的属性（比如指向图片资源的不同），可以做出各种动画效果。

===图形元素===
图片资源和声音资源不直接属于游戏屏幕，它们间接被元素引用或释放，并按需呈现或者隐藏。一个milk游戏可以有较多资源，但是同时使用的资源将是总资源的子集。

图形元素有可以有多种状态，并在这些状态之间按需切换：
  * 静态，引用一张图片资源
  * 动态，按一定帧速替换引用一组图片资源
  * 不引用任何图片资源

===背景拼图===
使用一系列的小图片来拼成大张的游戏背景，节约存储空间的使用。具体做法是将设计出来的大地图切分成若干张小图，剔除其中重复的部分，把不重复的部分命名并且拼成一张较小的图片资源，使用一个数组的形式在游戏程序运行时动态拼出原地图。

===文字元素===
可以规定整段文字的折行属性，宽高，颜色，字号（大中小三种）

====milk图形界面====

milk图形界面用来显示信息界面。它的后台使用的是修改过的moml3技术。
moml3技术是标签引擎，它支持类似html的标签，通过标签语言来定义页面外观。我们对moml3进行了大量的修改，移植，使得milk语言作为moml3的脚本存在，也就使得moml3变成了milk的ui库。通过milk与moml3的交互，程序可以动态生成，删除页面元素，修改元素属性，如宽高，字体，颜色，外框等属性，更改信息页面外观。

=====Milk 编译器=====

游戏硬件通常不能直接解析执行文本文件的程序源码，原因有二
  * 文本文件的解析涉及到字符串解析，对cpu和内存的要求较高，效率也比直接执行二进制字节码低下。
  * 如果考虑到在线更新逻辑，传输源码占用的网络带宽要远较传输编译过的执行字节码维多。
  * 不利于程序员线下调试，测试等等

综上，milk程序采取的方式是线下编译。也就是说：程序员开发，编译，调试都在线下，当一切通过后，才部署到服务器上任由用户更新，下载。

对于milk编译器和部署器来说，图片，声音等资源文件是资源，程序代码本身也是资源。所有的资源都可以由部署环境维护版本，提供给milk-runtime（客户端）的查询，更新和下载。也就是说，当一个被milk使用的图片资源有更新时，连线的milk-runtime将能通过部署环境（mgserver）进行查询，更新。当一段milk代码更新时，它对于milk-runtime来说和一个图片更新是没有区别的。

====需要编译的资源====
每个milk游戏、应用都有一个唯一的资源列表文件（resource.json），其中规定了若干种资源：
  - 场景（milk源码 .mk文件）
  - 页面 (moml3源码 .moml文件)
  - 图片
  - 声音
  - 翻译

等等

milk需要编译的资源有两种：
  * milk源码 .mk文件 （编译成功生成.bc字节码）
  * moml3源码 .moml文件 (编译成功生成.sv3字节码)

===milk源码===
milk源码必须出现在资源列表里边（resource.json）才会被编译器读取编译。一段milk源码可以是一个场景（scene），也可以是一个动态链接库（lib）。如果一段milk源码没有出现在资源列表中，它仍然可以被一个场景或者一个动态链接库引用(#include)，编译器遇到这种情况，将会进行preprocessing把被引用的内容与引用者联合编译，生成最后的产出（字节码）。这种方式是静态链接。如果一个场景引用的动态链接库（import），那么在运行时milk-runtime会按需执行动态链接库的字节码，这种方式叫做动态链接。

===moml3源码===
moml3源码里边可以也可以不包含milk脚本。如果它出现在资源列表(resource.json)里边，将会被编译成为一个页面(page)。这个页面将在运行时被milk-runtime按需动态加载，显示，释放，销毁。

=====milk部署器和milk部署环境=====
程序员或者milk相关人员均可在本地架设milk部署器和部署环境，以便调试开发。

milk部署环境，又称MgServer，是一个架设在monet上面的service。所以当需要部署在本地时，需要配置monet的 url, port, username/password的属性才能建立连接。

====MgServer的主要功能====
  * 接受milk程序的部署，并且维护资源版本号 （http）
  * 接受milk-runtime查询资源的最新版本 (monet）
  * 按需推送资源更新给milk-runtime (monet)
  * 邮递milk-runtime发送给游戏服务器的消息(http)，并发送回执 (monet)
  * 接收游戏服务器发给milk-runtime的消息(http)，并发送给milk-runtime(monet)
  * 帮助milk-runtime获取不在资源列表的外站资源(http),按需压缩处理，发送给milk-runtime（monet）
  * 按需（milk-runtime的user-agent）对图片资源进行压缩，发送给milk-runtime（monet）

可以看出，MgServer实际上是milk-runtime和游戏服务器中间的桥梁，兼资源管理中心。

=====milk-runtime=====

milk-runtime就是我们通常说的客户端，相对应的服务端则是游戏服务器。

已有的milk-runtime包括j2me, blackberry,正在开发的则有android和ios.未来准备支持的可能有desktop java和网页版。

为了支持不同的硬件，milk-runtime和java虚拟机采取了相似的机制，即将底层硬件抽象出来，使得milk程序可以直接在各种硬件上面运行。
但是每个milk-runtime都不可避免有些特殊性，比如硬件接口支持的不同：（多点触控，实体键盘，屏幕分辨率，内存大小，cpu速度，显示硬件的局限）。于是每个milk-runtime都需要报告自己的user-agent给MgServer以便判断应该适配何种资源（图片，逻辑实现【比如触屏和非触屏的导航】等等）。

milk-runtime是用硬件本身支持的编程语言写成的，它一般无法支持通过MgServer进行更新。对milk-runtime的更新一般只有要求用户重新下载安装，所以每次需要更新milk-runtime都是要小心慎重的。
